package oas

import (
	"encoding/json"

	"github.com/pkg/errors"
	"gopkg.in/yaml.v2"
)

// SecurityScheme defines a security scheme that can be used by the operations.
// Supported schemes are HTTP authentication, an API key (either as a header, a
// cookie parameter or as a query parameter), OAuth2's common flows (implicit,
// password, application and access code) as defined in RFC6749, and OpenID
// Connect Discovery.
type SecurityScheme struct {
	// Ref allow referencing other components in the specification, internally
	// and externally.
	Ref string `json:"$ref,omitempty" yaml:"$ref,omitempty"`

	// Type describes the type of the security scheme. Valid values are "apiKey",
	// "http", "oauth2", "openIdConnect".
	Type string `json:"type" yaml:"type"`

	// Description describes a short description for security scheme.
	// CommonMark syntax MAY be used for rich text representation.
	Description string `json:"description,omitempty" yaml:"description,omitempty"`

	// Name describes the name of the header, query or cookie parameter to be
	// used.
	Name string `json:"name" yaml:"name"`

	// In describes the location of the API key. Valid values are "query",
	// "header" or "cookie".
	In string `json:"in" yaml:"in"`

	// Scheme describes the name of the HTTP Authorization scheme to be used in
	// the Authorization header as defined in RFC7235.
	Scheme string `json:"scheme" yaml:"scheme"`

	// BearerFormat hints to the client to identify how the bearer token is
	// formatted. Bearer tokens are usually generated by an authorization
	// server, so this information is primarily for documentation purposes.
	BearerFormat string `json:"bearerFormat,omitempty" yaml:"bearerFormat,omitempty"`

	// Flows describes an object containing configuration information for the
	// flow types supported.
	Flows OAuthFlows `json:"flows" yaml:"flows"`

	// OpenIDConnectURL describes OpenId Connect URL to discover OAuth2
	// configuration values. This MUST be in the form of a URL.
	OpenIDConnectURL string `json:"openIdConnectUrl" yaml:"openIdConnectUrl"`

	// Extensions describes additional data can be added to extend the
	// specification at certain points.
	Extensions Extensions `json:"-" yaml:"-"`
}

// Clone returns a new deep copied instance of the object.
func (r SecurityScheme) Clone() (*SecurityScheme, error) {
	rbytes, err := yaml.Marshal(r)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	value := SecurityScheme{}
	if err := yaml.Unmarshal(rbytes, &value); err != nil {
		return nil, errors.WithStack(err)
	}
	return &value, nil
}

// MarshalJSON returns the JSON encoding.
func (r SecurityScheme) MarshalJSON() ([]byte, error) {
	obj, err := r.MarshalYAML()
	if err != nil {
		return nil, err
	}
	return json.Marshal(obj)
}

// UnmarshalJSON parses the JSON-encoded data and stores the result.
func (r *SecurityScheme) UnmarshalJSON(data []byte) error {
	return r.UnmarshalYAML(func(in interface{}) error {
		obj := make(map[string]interface{})
		if err := json.Unmarshal(data, &obj); err != nil {
			return errors.WithStack(err)
		}

		rbytes, err := yaml.Marshal(obj)
		if err != nil {
			return errors.WithStack(err)
		}

		if err := yaml.Unmarshal(rbytes, in); err != nil {
			return errors.WithStack(err)
		}
		return nil
	})
}

// MarshalYAML returns the YAML encoding.
func (r SecurityScheme) MarshalYAML() (interface{}, error) {
	obj := make(map[string]interface{})

	if r.Ref != "" {
		obj["$ref"] = r.Ref
	}

	obj["type"] = r.Type

	if r.Description != "" {
		obj["description"] = r.Description
	}

	obj["name"] = r.Name

	obj["in"] = r.In

	obj["scheme"] = r.Scheme

	if r.BearerFormat != "" {
		obj["bearerFormat"] = r.BearerFormat
	}

	obj["flows"] = r.Flows

	obj["openIdConnectUrl"] = r.OpenIDConnectURL

	for key, val := range r.Extensions {
		obj[key] = val
	}

	return obj, nil
}

// UnmarshalYAML parses the YAML-encoded data and stores the result.
func (r *SecurityScheme) UnmarshalYAML(unmarshal func(interface{}) error) error {
	obj := make(map[string]interface{})
	if err := unmarshal(&obj); err != nil {
		return errors.WithStack(err)
	}

	if value, ok := obj["$ref"]; ok {
		if value, ok := value.(string); ok {
			r.Ref = value
		}
	}

	if value, ok := obj["type"]; ok {
		if value, ok := value.(string); ok {
			r.Type = value
		}
	}

	if value, ok := obj["description"]; ok {
		if value, ok := value.(string); ok {
			r.Description = value
		}
	}

	if value, ok := obj["name"]; ok {
		if value, ok := value.(string); ok {
			r.Name = value
		}
	}

	if value, ok := obj["in"]; ok {
		if value, ok := value.(string); ok {
			r.In = value
		}
	}

	if value, ok := obj["scheme"]; ok {
		if value, ok := value.(string); ok {
			r.Scheme = value
		}
	}

	if value, ok := obj["bearerFormat"]; ok {
		if value, ok := value.(string); ok {
			r.BearerFormat = value
		}
	}

	if value, ok := obj["flows"]; ok {
		rbytes, err := yaml.Marshal(value)
		if err != nil {
			return errors.WithStack(err)
		}
		value := OAuthFlows{}
		if err := yaml.Unmarshal(rbytes, &value); err != nil {
			return errors.WithStack(err)
		}
		r.Flows = value
	}

	if value, ok := obj["openIdConnectUrl"]; ok {
		if value, ok := value.(string); ok {
			r.OpenIDConnectURL = value
		}
	}

	exts := Extensions{}
	if err := unmarshal(&exts); err != nil {
		return errors.WithStack(err)
	}

	if len(exts) > 0 {
		r.Extensions = exts
	}

	return nil
}
